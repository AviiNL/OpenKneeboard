/*
 * OpenKneeboard
 *
 * Copyright (C) 2022 Fred Emmott <fred@fredemmott.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 2.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 */
#include <OpenKneeboard/DeveloperToolsSettingsPage.hpp>
#include <OpenKneeboard/Filesystem.hpp>
#include <OpenKneeboard/JSObject.hpp>
#include <OpenKneeboard/PluginsSettingsPage.hpp>

#include <OpenKneeboard/format/filesystem.hpp>

#include <shims/winrt/base.h>

#include <winrt/Windows.UI.ViewManagement.h>

#include <filesystem>
#include <format>
#include <fstream>
#include <print>
#include <unordered_set>

#include <magic_enum.hpp>

namespace OpenKneeboard {

/* PS >
 * [System.Diagnostics.Tracing.EventSource]::new("OpenKneeboard.dump-js-exports")
 * 97080569-586a-5074-4e3c-0d1d53b60426
 */
TRACELOGGING_DEFINE_PROVIDER(
  gTraceProvider,
  "OpenKneeboard.dump-js-exports",
  (0x97080569, 0x586a, 0x5074, 0x4e, 0x3c, 0x0d, 0x1d, 0x53, 0xb6, 0x04, 0x26));

static auto GetGeneratedHeader() {
  // Using `@""g` to avoid marking this this C++ source file as generated
  return std::format(
    "// This file was automatically @"
    "generated by {}\n// DO NOT EDIT THIS FILE BY HAND.\n\n",
    Filesystem::GetCurrentExecutablePath().filename());
}

template <StringTemplateParameter TJSName>
struct BasicJSTypeInfo {
  static constexpr std::string_view js_typename_v {TJSName};
  static constexpr std::string_view js_argument_type_v {TJSName};
  static constexpr bool requires_import_v = false;
};

template <>
struct JSTypeInfo<std::string> : BasicJSTypeInfo<"string"> {};

template <>
struct JSTypeInfo<std::filesystem::path> : BasicJSTypeInfo<"string"> {};

template <>
struct JSTypeInfo<bool> : BasicJSTypeInfo<"boolean"> {};

template <class T>
  requires requires { JSClass<T>::GetJSTypeName(); }
struct JSTypeInfo<T> {
  static constexpr std::string_view js_typename_v {JSClass<T>::GetJSTypeName()};
  static constexpr std::string_view js_argument_type_v {
    JSClass<T>::GetArgumentType()};
  static constexpr bool requires_import_v = true;
};

template <class T>
  requires requires { JSEnum<T>::GetJSTypeName(); }
struct JSTypeInfo<T> {
  static constexpr std::string_view js_typename_v {JSEnum<T>::GetJSTypeName()};
  static constexpr std::string_view js_argument_type_v {
    JSEnum<T>::GetArgumentType()};
  static constexpr bool requires_import_v = true;
};

namespace {

using Dependencies = std::unordered_set<std::string>;

auto GetTypeScriptPropertyAccessor(auto prop) {
  const auto getter = std::format(
    R"TS(
get {1}(): {0} {{
  return this.#cpp_{1};
}}
)TS",
    prop.GetJSTypeName(),
    prop.GetName());
  if (prop.is_read_only_v) {
    return getter;
  }

  const auto setter = std::format(
    R"TS(
set {1}(value: {0}) {{
  if (this.#cpp_{1} === value) {{
    return;
  }}
  this.#cpp_{1} = value;
  this.NativePropertyChanged("{1}", value);
}}
)TS",
    prop.GetJSTypeName(),
    prop.GetName());

  return getter + setter;
}

template <class T>
auto GetTypeScriptPropertyAccessors() {
  if constexpr (has_js_properties<T>) {
    return JSClass<T>::MapProperties(
             [](auto p) { return GetTypeScriptPropertyAccessor(p); })
      | std::views::join_with('\n') | std::ranges::to<std::string>();
  } else {
    return std::string {};
  }
}

auto GetTypeScriptMethod(Dependencies& deps, auto method) {
  using Args = decltype(method)::arguments_t;

  const auto makeArg = []<size_t I>() constexpr {
    return std::pair {
      JSTypeInfo<std::tuple_element_t<I, Args>>::template js_argument_type_v,
      std::format("arg{}", I),
    };
  };

  const auto argVisitor = [&](auto arg) constexpr -> std::string_view {
    if (arg.requires_import_v) {
      deps.emplace(arg.js_typename_v);
    }
    return arg.js_argument_type_v;
  };

  const auto args = [&]<size_t... I>(std::index_sequence<I...>) constexpr {
    if constexpr (sizeof...(I) == 0) {
      return std::views::empty<std::string_view>;
    } else {
      return std::array {
        argVisitor(JSTypeInfo<std::tuple_element_t<I, Args>> {})...};
    }
  }(std::make_index_sequence<std::tuple_size_v<Args>>());

  return std::format(
    R"TS(
{0}({1}): void {{
  this.InvokeNativeMethod("{0}", [{2}]);
}}
)TS",
    method.GetName(),
    std::ranges::fold_left_first(
      args | std::views::enumerate | std::views::transform([](const auto& it) {
        const auto& [index, type] = it;
        return std::format("arg{}: {}", index, type);
      }),
      [](const auto& acc, const auto& it) {
        return std::format("{}, {}", acc, it);
      })
      .value_or(""),
    std::ranges::fold_left_first(
      std::views::iota(std::size_t {0}, std::tuple_size_v<Args>)
        | std::views::transform([](auto i) { return std::format("arg{}", i); }),
      [](const auto& acc, const auto& it) {
        return std::format("{}, {}", acc, it);
      })
      .value_or(""));
}

template <class T>
auto GetTypeScriptMethods(Dependencies& deps) {
  if constexpr (has_js_methods<T>) {
    return JSClass<T>::MapMethods(
             [&](auto m) { return GetTypeScriptMethod(deps, m); })
      | std::views::join_with('\n') | std::ranges::to<std::string>();
  } else {
    return std::string {};
  }
}

template <class T>
std::string GetTypeScriptPropertyAssignments() {
  if constexpr (has_js_properties<T>) {
    return JSClass<T>::MapProperties([](auto prop) {
             return std::format(
               "this.#cpp_{0} = instanceData['{0}'];", prop.GetName());
           })
      | std::views::join_with('\n') | std::ranges::to<std::string>();
  }
  return {};
}

template <class T>
auto GetTypeScriptConstructor() {
  return std::format(
    R"TS(
private constructor(instanceID: string, instanceData: any) {{
  super(instanceID);
  {0}
}}

static async load(instanceID: string): Promise<{1}> {{
  return new {1}(instanceID, await this.GetInstanceJSONData("{2}", instanceID));
}}
)TS",
    GetTypeScriptPropertyAssignments<T>(),
    JSClass<T>::GetJSTypeName(),
    JSClass<T>::GetCPPTypeName());
}

template <class T>
auto GetTypeScriptPropertyStorage() {
  if constexpr (has_js_properties<T>) {
    return JSClass<T>::MapProperties([](auto prop) {
             return std::format(
               "#cpp_{}: {};", prop.GetName(), prop.GetJSTypeName());
           })
      | std::views::join_with('\n') | std::ranges::to<std::string>();
  } else {
    return std::string {};
  }
}

template <class T>
auto GetTypeScriptTypeAliases(const Dependencies& deps) {
  static constexpr auto prefix = JSClass<T>::js_type_name_v + "_"_tp;
  return deps
    | std::views::filter([](auto it) { return it.starts_with(prefix); })
    | std::views::transform([](auto it) {
           return std::format(
             "export const {} = {};",
             std::string_view {it.begin() + prefix.size(), it.end()},
             it);
         })
    | std::views::join | std::ranges::to<std::string>();
}

template <class T>
auto GetTypeScriptClass(Dependencies& deps) {
  const std::array parts {
    GetTypeScriptConstructor<T>(),
    GetTypeScriptPropertyStorage<T>(),
    GetTypeScriptPropertyAccessors<T>(),
    GetTypeScriptMethods<T>(deps),
  };

  const auto classCode = std::format(
    R"TS(
export class {0} extends NativeClass {{
  {1}
}}
export default {0};
)TS",
    std::string_view {JSClass<T>::js_type_name_v},
    std::views::join(parts) | std::ranges::to<std::string>());

  const auto aliases = GetTypeScriptTypeAliases<T>(deps);
  return std::format("{}\n{}", classCode, aliases);
}

static constexpr auto EscCursorSave = "\0337";
static constexpr auto EscCursorRestore = "\0338";
static constexpr auto EscCursorUp = "\033M";
static constexpr auto EscColorGray = "\033[38;2;128;128;128m";
static constexpr auto EscReset = "\033[0m";

template <class T>
void ExportTypeScriptClass() {
  const auto name = JSClass<T>::GetJSTypeName();
  std::println("Exporting {}:{}", name, EscCursorSave);
  const auto path = std::format("{}.ts", name);

  Dependencies deps;

  const auto code = GetTypeScriptClass<T>(deps);

  std::string imports;
  for (const auto& dep: deps) {
    imports += std::format("import {0} from \"./{0}\";\n", dep);
  }

  {
    std::ofstream f(path, std::ios::binary | std::ios::trunc);
    f << GetGeneratedHeader()
      << "import NativeClass from \"../src/NativeClass\";\n"
      << imports << code;
  }

  std::println(
    "{}{} OK\n  {}{}{}",
    EscCursorRestore,
    EscCursorUp,
    EscColorGray,
    std::filesystem::absolute(path),
    EscReset);
}

template <class T>
void ExportTypeScriptEnum() {
  const auto name = JSEnum<T>::GetJSTypeName();
  std::println("Exporting {}:{}", name, EscCursorSave);
  const auto path = std::format("{}.ts", name);

  const auto code = std::format(
    "enum {0} {{ {1} }}\nexport default {0};",
    name,
    magic_enum::enum_names<T>() | std::views::transform([](auto it) {
      return std::format("{0} = \"{0}\",", it);
    }) | std::views::join
      | std::ranges::to<std::string>());

  {
    std::ofstream f(path, std::ios::binary | std::ios::trunc);
    f << GetGeneratedHeader() << code;
  }

  std::println(
    "{}{} OK\n  {}{}{}",
    EscCursorRestore,
    EscCursorUp,
    EscColorGray,
    std::filesystem::absolute(path),
    EscReset);
}
}// namespace
}// namespace OpenKneeboard

using namespace OpenKneeboard;

static const std::filesystem::path StampFile {"stamp"};

static void RemoveOldFiles() {
  const auto removed = [](auto path) {
    std::println(
      "  {}{}{}", EscColorGray, std::filesystem::absolute(path), EscReset);
  };

  std::println("Removing old files");
  for (auto&& it:
       std::filesystem::directory_iterator(std::filesystem::current_path())) {
    if (!it.is_regular_file()) {
      continue;
    }
    const auto& path = it.path();
    if (path.extension() != ".ts") {
      continue;
    }
    std::filesystem::remove(path);
    removed(path);
  }
}

static void ExportSystemTheme() {
  std::vector<std::string> uiColorTypes;
  std::vector<std::string> uiElementTypes;

  using namespace winrt::Windows::UI::ViewManagement;

  for (auto&& [enumValue, name]: magic_enum::enum_entries<UIColorType>()) {
    if (enumValue == UIColorType::Complement) {
      continue;
    }
    uiColorTypes.push_back(std::format("\"{}\"", name));
  }
  for (auto&& name: magic_enum::enum_names<UIElementType>()) {
    uiElementTypes.push_back(std::format("\"{}\"", name));
  }

  const auto code = std::format(
    R"TS(
export type UIColorType = {};
export type UIElementType = {};
export default interface SystemTheme {{
  uiColors: Record<UIColorType, string>,
  uiElementColors: Record<UIElementType, string>,
}}
)TS",
    uiColorTypes | std::views::join_with('|') | std::ranges::to<std::string>(),
    uiElementTypes | std::views::join_with('|')
      | std::ranges::to<std::string>());

  std::ofstream f("SystemTheme.d.ts", std::ios::trunc | std::ios::binary);
  f << GetGeneratedHeader() << code;
}

int main(int argc, char** argv) {
  RemoveOldFiles();

  ExportSystemTheme();

  ExportTypeScriptEnum<DeveloperToolsSettingsPage::CrashKind>();
  ExportTypeScriptEnum<DeveloperToolsSettingsPage::CrashLocation>();
  ExportTypeScriptClass<DeveloperToolsSettingsPage>();

  ExportTypeScriptClass<PluginsSettingsPage>();
  ExportTypeScriptClass<Plugin::Metadata>();

  return 0;
}