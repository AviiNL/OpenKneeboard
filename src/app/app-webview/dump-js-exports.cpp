/*
 * OpenKneeboard
 *
 * Copyright (C) 2022 Fred Emmott <fred@fredemmott.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 2.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 */
#include <OpenKneeboard/DeveloperToolsSettingsPage.hpp>
#include <OpenKneeboard/Filesystem.hpp>
#include <OpenKneeboard/JSObject.hpp>

#include <OpenKneeboard/format/filesystem.hpp>

#include <shims/winrt/base.h>

#include <winrt/Windows.UI.ViewManagement.h>

#include <filesystem>
#include <format>
#include <fstream>
#include <print>

#include <magic_enum.hpp>

namespace OpenKneeboard {

/* PS >
 * [System.Diagnostics.Tracing.EventSource]::new("OpenKneeboard.dump-js-exports")
 * 97080569-586a-5074-4e3c-0d1d53b60426
 */
TRACELOGGING_DEFINE_PROVIDER(
  gTraceProvider,
  "OpenKneeboard.dump-js-exports",
  (0x97080569, 0x586a, 0x5074, 0x4e, 0x3c, 0x0d, 0x1d, 0x53, 0xb6, 0x04, 0x26));

static auto GetGeneratedHeader() {
  // Using `@""g` to avoid marking this this C++ source file as generated
  return std::format(
    "// This file was automatically @"
    "generated by {}\n// DO NOT EDIT THIS FILE BY HAND.\n",
    Filesystem::GetCurrentExecutablePath().filename());
}

template <>
struct JSTypeInfo<std::string> {
  static constexpr std::string_view js_typename_v {"string"};
};

template <>
struct JSTypeInfo<std::filesystem::path> {
  static constexpr std::string_view js_typename_v {"string"};
};

template <>
struct JSTypeInfo<bool> {
  static constexpr std::string_view js_typename_v {"boolean"};
};

namespace {

auto GetTypeScriptPropertyAccessor(auto prop) {
  const auto getter = std::format(
    R"TS(
get {1}(): {0} {{
  return this.#cpp_{1};
}}
)TS",
    prop.GetTypeName(),
    prop.GetName());
  if (prop.is_read_only_v) {
    return getter;
  }

  const auto setter = std::format(
    R"TS(
set {1}(value: {0}) {{
  if (this.#cpp_{1} === value) {{
    return;
  }}
  this.#cpp_{1} = value;
  this.NativePropertyChanged("{1}", value);
}}
)TS",
    prop.GetTypeName(),
    prop.GetName());

  return getter + setter;
}

template <class T>
auto GetTypeScriptPropertyAccessors() {
  return JSClass<T>::MapProperties(
           [](auto p) { return GetTypeScriptPropertyAccessor(p); })
    | std::views::join_with('\n') | std::ranges::to<std::string>();
}

auto GetTypeScriptMethod(auto method) {
  return std::format(
    R"TS(
{0}(): void {{
  this.InvokeNativeMethod("{0}");
}}
)TS",
    method.GetName());
}
template <class T>
auto GetTypeScriptMethods() {
  return JSClass<T>::MapMethods([](auto m) { return GetTypeScriptMethod(m); })
    | std::views::join_with('\n') | std::ranges::to<std::string>();
}

template <class T>
auto GetTypeScriptConstructor() {
  const auto propAssignments
    = JSClass<T>::MapProperties([](auto prop) {
        return std::format(
          "this.#cpp_{0} = instanceData['{0}'];", prop.GetName());
      })
    | std::views::join_with('\n') | std::ranges::to<std::string>();
  ;

  return std::format(
    R"TS(
constructor(instanceID: string, instanceData: any) {{
  super(instanceID);
  {0}
}}
)TS",
    propAssignments);
}

template <class T>
auto GetTypeScriptPropertyStorage() {
  return JSClass<T>::MapProperties([](auto prop) {
           return std::format(
             "#cpp_{}: {};", prop.GetName(), prop.GetTypeName());
         })
    | std::views::join_with('\n') | std::ranges::to<std::string>();
}

template <class T>
auto GetTypeScriptClass() {
  return std::format(
    R"TS(
export default class {} extends OpenKneeboardNativeClass {{
  {}
  {}
  {}
  {}
}}
)TS",
    std::string_view {JSClass<T>::class_name_v},
    GetTypeScriptConstructor<T>(),
    GetTypeScriptPropertyStorage<T>(),
    GetTypeScriptPropertyAccessors<T>(),
    GetTypeScriptMethods<T>());
}

static constexpr auto EscCursorSave = "\0337";
static constexpr auto EscCursorRestore = "\0338";
static constexpr auto EscCursorUp = "\033M";
static constexpr auto EscColorGray = "\033[38;2;128;128;128m";
static constexpr auto EscReset = "\033[0m";

template <class T>
void ExportTypeScriptClass() {
  const auto name = JSClass<T>::GetTypeName();
  std::println("Exporting {}:{}", name, EscCursorSave);
  const auto path = std::format("{}.ts", name);
  const auto code = GetTypeScriptClass<T>();
  {
    std::ofstream f(path, std::ios::binary | std::ios::trunc);
    f << GetGeneratedHeader()
      << "\nimport OpenKneeboardNativeClass from "
         "\"../src/OpenKneeboardNativeClass\";\n"
      << code;
  }
  std::println(
    "{}{} OK\n  {}{}{}",
    EscCursorRestore,
    EscCursorUp,
    EscColorGray,
    std::filesystem::absolute(path),
    EscReset);
}

}// namespace
}// namespace OpenKneeboard

using namespace OpenKneeboard;

static const std::filesystem::path StampFile {"stamp"};

static void RemoveOldFiles() {
  const auto removed = [](auto path) {
    std::println(
      "  {}{}{}", EscColorGray, std::filesystem::absolute(path), EscReset);
  };

  std::println("Removing old files");
  for (auto&& it:
       std::filesystem::directory_iterator(std::filesystem::current_path())) {
    if (!it.is_regular_file()) {
      continue;
    }
    const auto& path = it.path();
    if (path.extension() != ".ts") {
      continue;
    }
    std::filesystem::remove(path);
    removed(path);
  }
}

static void ExportSystemTheme() {
  std::vector<std::string> uiColorTypes;
  std::vector<std::string> uiElementTypes;

  using namespace winrt::Windows::UI::ViewManagement;

  for (auto&& [enumValue, name]: magic_enum::enum_entries<UIColorType>()) {
    if (enumValue == UIColorType::Complement) {
      continue;
    }
    uiColorTypes.push_back(std::format("\"{}\"", name));
  }
  for (auto&& name: magic_enum::enum_names<UIElementType>()) {
    uiElementTypes.push_back(std::format("\"{}\"", name));
  }

  const auto code = std::format(
    R"TS(
export type UIColorType = {};
export type UIElementType = {};
export default interface SystemTheme {{
  uiColors: Record<UIColorType, string>,
  uiElementColors: Record<UIElementType, string>,
}}
)TS",
    uiColorTypes | std::views::join_with('|') | std::ranges::to<std::string>(),
    uiElementTypes | std::views::join_with('|')
      | std::ranges::to<std::string>());

  std::ofstream f("SystemTheme.d.ts", std::ios::trunc | std::ios::binary);
  f << GetGeneratedHeader() << code;
}

int main(int argc, char** argv) {
  RemoveOldFiles();

  ExportSystemTheme();

  ExportTypeScriptClass<DeveloperToolsSettingsPage>();

  std::println("Creating stamp file:{}", EscCursorSave);
  { std::ofstream f(StampFile, std::ios::trunc); }
  std::println(
    "{}{} OK\n  {}{}{}",
    EscCursorRestore,
    EscCursorUp,
    EscColorGray,
    std::filesystem::absolute(StampFile),
    EscReset);

  return 0;
}